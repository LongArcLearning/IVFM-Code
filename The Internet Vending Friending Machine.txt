// The Internet Vending Friending Machine// Version 1.0  1/7/2017  Bryant M. Patten  (BMP)// The Internet Vending Friend Machine is a distributed Internet of Things Vending machine//   It can have a variable number of actual machines at any location in the world.//   Inserting a quarter and pressing a 'Vend' button on one machine will cause a piece of chocolate //    to be dispensed at a different machine.//   The Internet Vending Friending machine is different from traditional machines in that: //     WHAT it vends is constant - it can only dispense one thing//     WHERE it vends is variable - it can dispense at any of the machines in the set.//   This first prototype will be a four machine set so it will have four vending buttons.// The machines communicate through the Particle Publish and Subscribe model with an 'IVFM_Event'//   All machines both publish events (button push) and subscribe (dispense chocolate)//   Each type of event is identified by the data value passed with the IVFM_Event//   Each machine responds to any event will a data value within its range //    Machine #1 responds to events with values of 100-199, Machine #2 200-299, etc// Pins D1-D4 are assigned to the LEDs in the choice buttons// Pins A1-A4 are assigned to the switches in the choice buttons.  Normally, digitals pins would be used but there aren't enough// Pin D5 is used for the coin acceptor// Unique identifier for this machine - each machine assigned one unique value from 1 to 4int thisMachineSetID = 2;  // Machine #1//Sometimes random spike on the coin pulse line happens so we need to count the pulsesint pulseCount = 0;// Event range valuesint mRange = 100;int mRangeBase;int mRangeTop;Servo LA_Servo;// This variable records which button is pressedlong dataEventValue = 0;//It is possible to request candy from other machine ownersint requestedCandy = 0;long candyRequestTime = 0;//A machine can request the online status of another machineint myPins[] = {2, 4, 8, 3, 6};int curOnlineArray[] = {0, 0, 0, 0, 0};boolean coinAccepted = FALSE;  void setup() {        SetUpPins();    SetUpRangeValues();        //Set up the servo    LA_Servo.attach(A5);    // Some docs say that it is best not to drive the servo to 0    LA_Servo.write(5);    LA_Servo.detach();        //Flash all the LEDS to make sure they all still work.    CheckLEDs();        //Set up the coin acceptance mechanism    attachInterrupt(D6, CoinApproved, RISING);           //Set up messaging system between machines    Particle.subscribe("IVFM_Event",IFVM_Respond);}void loop() {        // Make sure the wifi is on - show this by using the button for this machine.  If machineID = 3 light the 3rd button    CheckWifi();        if(coinAccepted == TRUE){        Blink_All_LEDs();    }    CheckForButtonPress();        delay(200);    // This shouldn't be necessary but the coin acceptor get random pusles and if this value not cleared, evenutaully thinks a coin has been dropped.    pulseCount = 0;        if(requestedCandy != 0){        RequestCandyTimeCheck();    }}// If a coin has been acccepted, blink all lights  to indicate that the person should make a choice and push a buttonvoid All_LEDs_Off(){        // Blink all vendable machines - so not THIS machine's button    for (int thisPin = 1; thisPin <=4; thisPin++) {        if(thisPin != thisMachineSetID){            digitalWrite(thisPin, LOW);        }      }         }// If a coin has been acccepted, blink all lights to indicate that the person should make a choice and push a buttonvoid Blink_All_LEDs(){        // Turn off the light for this machine    digitalWrite(thisMachineSetID, LOW);        for (int thisPin = 1; thisPin <=4; thisPin++) {        //Don't blink THIS machines button since you can't vend from this machine        if(thisPin != thisMachineSetID){          digitalWrite(thisPin, HIGH);        }      }        delay(500);         for (int thisPin = 1; thisPin <=4; thisPin++) {        if(thisPin != thisMachineSetID){            digitalWrite(thisPin, LOW);        }      }        delay(500);   }// This routines is the heart of the machine.  It checks to see if any of the button have been pressed and//  if they have been pressed, publishes the right data to the rest of the machinesvoid CheckForButtonPress(){    //If there is no coin, the button will not work        for (int thisPin = 11; thisPin <=14; thisPin++) {        if(digitalRead(thisPin) == LOW){  //Is there a button pressed?            if(thisPin == thisMachineSetID+10) {   //Is this the machine owner's button - which cannot vend                dataEventValue = 1111*thisMachineSetID;  // set message to 'send me candy' for this machine                Particle.publish("IVFM_Event",String(dataEventValue),60,PUBLIC);                    requestedCandy = thisMachineSetID;                candyRequestTime = Time.now();                }else if (coinAccepted == TRUE) {  //This is a choice of machine after a coin drip                    dataEventValue = (thisMachineSetID * 1000) + ((thisPin-10) * 100) + 3;                    Particle.publish("IVFM_Event",String(dataEventValue),60,PUBLIC);                    coinAccepted = FALSE;                    digitalWrite(D7, LOW);                    All_LEDs_Off();                    }else {  // If they push a unlit button, it is a requewst to see if the person is online                        curOnlineArray[(thisPin-10)] = ((thisPin-10) * 1000) + ((thisPin-10) * 100) + 5;                        dataEventValue = (thisMachineSetID * 1000) + ((thisPin-10) * 100) + 4;                        Particle.publish("IVFM_Event",String(dataEventValue),60,PUBLIC);                                            }            while(digitalRead(thisPin) == LOW) {                // hang out here until button released so it only published one event            }        }      }     }// This startup actions just shows that power is connected and all embedded LEDs are still workingvoid CheckLEDs() {  for (int thisPin = 1; thisPin <=4; thisPin++) {                //Flash all the pins EXCEPT the button for this machine        if(thisPin != thisMachineSetID){            // turn the pin on:            digitalWrite(thisPin, HIGH);            delay(200);            // turn the pin off:            digitalWrite(thisPin, LOW);            delay(200);         }              }}void CheckOnlineStatusOfAllMachines(){        for (int thisPin = 1; thisPin <=4; thisPin++) {        curOnlineArray[(thisPin-10)] = ((thisPin-10) * 1000) + ((thisPin-10) * 100) + 5;        dataEventValue = (thisMachineSetID * 1000) + ((thisPin-10) * 100) + 4;        Particle.publish("IVFM_Event",String(dataEventValue),60,PUBLIC);    }            }//Checks to see if this machine is still connectedvoid CheckWifi(){   if(Particle.connected()==TRUE){         digitalWrite(thisMachineSetID, HIGH);   //NOTE: Pin Value should be changed to match machine   }    else {         digitalWrite(thisMachineSetID, LOW);   }   }void CoinApproved(){        pulseCount += 1;        //The coin acceptor should sense 5 pulses        if(pulseCount == 5){        coinAccepted = TRUE;        // if there is a live candy request, shut it down         requestedCandy = 0;        candyRequestTime = 0;                digitalWrite(D7, HIGH);         pulseCount = 0;    }}// This is the rountine that responds to published eventsvoid IFVM_Respond(const char *event, const char *data){    int curData;            curData = atoi(data);        for (int thisPin = 11; thisPin <=14; thisPin++) {        if(curData == curOnlineArray[(thisPin-10)]) { // This is a repsonse to a online status request            StatusResponse(curData);            return;        }        }            if ((curData == 1111) || (curData == 2222) || (curData == 3333) || (curData == 4444)) {        RequestCandy(curData);    } else {        curData = curData % 1000;  //strip off the sending machine value        if(curData == (thisMachineSetID * 100)+3) { // If this is a candy vedning...            digitalWrite(D7, HIGH);             VendCandy();            delay(2000);                          digitalWrite(D7, LOW);         } else  if(curData == (thisMachineSetID * 100)+4) { // If this is a status check...        // Publish a new event that shows this machine is awake            dataEventValue = (thisMachineSetID * 1000) + (thisMachineSetID * 100) + 5;            Particle.publish("IVFM_Event",String(dataEventValue),60,PUBLIC);                    }             }}// A machine ownder can request a candy py pressing their own machine buttonvoid RequestCandy(int curValue){        requestedCandy = curValue/1111;        candyRequestTime = Time.now();    } //Check to see if the request has timed out and, if so, stop the blinking.void RequestCandyTimeCheck(){    //gas ut been blinking for long enough...    if((Time.now() - candyRequestTime) > 30 ){        requestedCandy = 0;        candyRequestTime = 0;    } else {        digitalWrite(requestedCandy, HIGH);        delay(200);        // turn the pin off:        digitalWrite(requestedCandy, LOW);        delay(200);     }        for (int thisPin = 11; thisPin <=14; thisPin++) {                    curOnlineArray[(thisPin-10)]  = 0;        }   }// Establish pin mapping for push buttons and their embedded LEDs// The code would be shorter if I used arrays but it is slightly more readable this way//  and there are only 4 swtichesvoid SetUpPins() {        //set up pushbuttons    pinMode(A1,INPUT_PULLUP);    pinMode(A2,INPUT_PULLUP);    pinMode(A3,INPUT_PULLUP);    pinMode(A4,INPUT_PULLUP);        //set up LEDs    pinMode(D1,OUTPUT);    pinMode(D2,OUTPUT);    pinMode(D3,OUTPUT);    pinMode(D4,OUTPUT);        //set up servo pin    pinMode(A5,OUTPUT);         //setup coin signal    pinMode(D6,INPUT_PULLDOWN);        // temp testing     pinMode(D7,OUTPUT);    }// Establish the range of events to which this machine will respondvoid SetUpRangeValues() {    mRangeBase = thisMachineSetID * mRange;    mRangeTop = mRangeBase + (mRange - 1);}// Proovide the UI for a status request responsevoid StatusResponse(int curLiveMachine){    int ledToBlink;    // First dig contains which led to blink    ledToBlink = curLiveMachine /1000 ;  // Counting on integer division to just return the first digit        for(int blinkCount = 1; blinkCount <=20; blinkCount++){        digitalWrite(ledToBlink, HIGH);        delay(100);        // turn the pin off:        digitalWrite(ledToBlink, LOW);        delay(100);     }    }void VendCandy(){        // If you requested candy, shut down the blink    if(requestedCandy == thisMachineSetID) {        requestedCandy = 0;        candyRequestTime = 0;    }    LA_Servo.attach(A5);    LA_Servo.write(90);    delay(2000);    LA_Servo.write(130);    delay(2000);    LA_Servo.write(90);    delay(2000);    LA_Servo.detach();}